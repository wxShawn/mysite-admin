const O=(e={})=>{var o;const{root:n=null}=e;return{hash:`${e.rootMargin||"0px 0px 0px 0px"}-${Array.isArray(e.threshold)?e.threshold.join(","):(o=e.threshold)!==null&&o!==void 0?o:"0"}`,options:Object.assign(Object.assign({},e),{root:(typeof n=="string"?document.querySelector(n):n)||document.documentElement})}},h=new WeakMap,c=new WeakMap,u=new WeakMap,M=(e,o,n)=>{if(!e)return()=>{};const r=O(o),{root:i}=r.options;let t;const v=h.get(i);v?t=v:(t=new Map,h.set(i,t));let a,s;t.has(r.hash)?(s=t.get(r.hash),s[1].has(e)||(a=s[0],s[1].add(e),a.observe(e))):(a=new IntersectionObserver(p=>{p.forEach(d=>{if(d.isIntersecting){const l=c.get(d.target),g=u.get(d.target);l&&l(),g&&(g.value=!0)}})},r.options),a.observe(e),s=[a,new Set([e])],t.set(r.hash,s));let b=!1;const f=()=>{b||(c.delete(e),u.delete(e),b=!0,s[1].has(e)&&(s[0].unobserve(e),s[1].delete(e)),s[1].size<=0&&t.delete(r.hash),t.size||h.delete(i))};return c.set(e,f),u.set(e,n),f};export{M as o};
